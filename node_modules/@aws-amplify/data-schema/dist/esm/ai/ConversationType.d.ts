import type { Subscription } from 'rxjs';
import type { DefineFunction } from '@aws-amplify/data-schema-types';
import type { ListReturnValue, SingularReturnValue } from '../runtime/client';
import { type Brand } from '../util';
import type { RefType } from '../RefType';
import { AiModel, InferenceConfiguration } from './ModelType';
import { ConversationMessageContent, ConversationSendMessageInputContent } from './types/ConversationMessageContent';
import { ToolConfiguration } from './types/ToolConfiguration';
export declare const brandName = "conversationCustomOperation";
export interface ConversationMessage {
    content: ConversationMessageContent[];
    conversationId: string;
    createdAt: string;
    id: string;
    role: 'user' | 'assistant';
}
interface ConversationRouteGetInput {
    id: string;
}
interface ConversationRouteDeleteInput {
    id: string;
}
interface ConversationRouteListInput {
    limit?: number;
    nextToken?: string | null;
}
export interface ConversationRoute {
    /**
     * @experimental
     *
     * Creates a {@link Conversation} from the current conversation route.
     */
    create: () => SingularReturnValue<Conversation>;
    /**
     * @experimental
     *
     * Gets an existing {@link Conversation} based on ID.
     */
    get: (input: ConversationRouteGetInput) => SingularReturnValue<Conversation>;
    /**
     * @experimental
     *
     * Deletes an existing {@link Conversation} based on ID.
     */
    delete: (input: ConversationRouteDeleteInput) => SingularReturnValue<Conversation>;
    /**
     * @experimental
     *
     * Lists all existing {@link Conversation}s on the current conversation route.
     */
    list: (input?: ConversationRouteListInput) => ListReturnValue<Conversation>;
}
interface ConversationSendMessageInputObject {
    content: ConversationSendMessageInputContent[];
    aiContext?: string | Record<string, any>;
    toolConfiguration?: ToolConfiguration;
}
export type ConversationSendMessageInput = ConversationSendMessageInputObject | string;
interface ConversationListMessagesInput {
    limit?: number;
    nextToken?: string | null;
}
type ConversationOnMessageHandler = (message: ConversationMessage) => void;
export interface Conversation {
    id: string;
    createdAt: string;
    updatedAt: string;
    metadata?: Record<string, any>;
    name?: string;
    /**
     * @experimental
     *
     * Sends a message to the current conversation.
     */
    sendMessage: (input: ConversationSendMessageInput | string) => SingularReturnValue<ConversationMessage>;
    /**
     * @experimental
     *
     * Lists all existing messages for the current conversation.
     */
    listMessages: (input?: ConversationListMessagesInput) => ListReturnValue<ConversationMessage>;
    /**
     * @experimental
     *
     * Subscribes to new messages on the current conversation.
     */
    onMessage: (handler: ConversationOnMessageHandler) => Subscription;
}
export interface ToolDefinition {
    query: RefType<any>;
    description: string;
}
export interface ConversationInput {
    aiModel: AiModel;
    systemPrompt: string;
    inferenceConfiguration?: InferenceConfiguration;
    tools?: ToolDefinition[];
    handler?: DefineFunction;
}
export interface InternalConversationType extends ConversationType, ConversationInput {
}
export interface ConversationType extends Brand<typeof brandName> {
}
/**
 * @experimental
 *
 * Define an AI conversation route which enables multi-turn conversation APIs for interacting with specified AI model.
 * @example
 * realtorChat: a.conversation({
 *   aiModel: { resourcePath },
 *   systemPrompt: 'You are a helpful real estate assistant',
 * })
 * @returns a conversation route definition
 */
export declare function conversation(input: ConversationInput): ConversationType;
export {};
