'use strict';

Object.defineProperty(exports, "__esModule", { value: true });
exports.ipAddress = exports.url = exports.phone = exports.json = exports.email = exports.timestamp = exports.datetime = exports.time = exports.date = exports.boolean = exports.float = exports.integer = exports.string = exports.id = exports.ModelFieldDataType = exports.ModelFieldType = exports.__generated = exports.__auth = void 0;
const util_1 = require("./util");
const Authorization_1 = require("./Authorization");
/**
 * Used to "attach" auth types to ModelField without exposing them on the builder.
 */
exports.__auth = Symbol('__auth');
/**
 * Used by `.default()` to represent a generated field (SQL).
 */
exports.__generated = Symbol('__generated');
const brandName = 'modelField';
var ModelFieldType;
(function (ModelFieldType) {
    ModelFieldType["Id"] = "ID";
    ModelFieldType["String"] = "String";
    ModelFieldType["Integer"] = "Int";
    ModelFieldType["Float"] = "Float";
    ModelFieldType["Boolean"] = "Boolean";
    ModelFieldType["Date"] = "AWSDate";
    ModelFieldType["Time"] = "AWSTime";
    ModelFieldType["DateTime"] = "AWSDateTime";
    ModelFieldType["Timestamp"] = "AWSTimestamp";
    ModelFieldType["Email"] = "AWSEmail";
    ModelFieldType["JSON"] = "AWSJSON";
    ModelFieldType["Phone"] = "AWSPhone";
    ModelFieldType["Url"] = "AWSURL";
    ModelFieldType["IPAddress"] = "AWSIPAddress";
})(ModelFieldType || (exports.ModelFieldType = ModelFieldType = {}));
var ModelFieldDataType;
(function (ModelFieldDataType) {
    ModelFieldDataType["String"] = "string";
    ModelFieldDataType["Number"] = "number";
    ModelFieldDataType["Boolean"] = "boolean";
    ModelFieldDataType["Date"] = "Date";
    ModelFieldDataType["JSON"] = "any";
})(ModelFieldDataType || (exports.ModelFieldDataType = ModelFieldDataType = {}));
/**
 * Model Field Implementation
 *
 * @typeParam T - holds the JS data type of the field; invoking the public methods changes this type accordingly
 * @example
 * string() => T = string | null
 * string().array() => T = Array<string | null> | null
 * string().array().required() => T = Array<string | null>
 * string().required().array().required() => T = Array<string>
 *
 * @param fieldType - stores the GraphQL data type of the field
 */
function _field(fieldType) {
    const _meta = {
        lastInvokedMethod: null,
    };
    const data = {
        fieldType,
        required: false,
        array: false,
        arrayRequired: false,
        default: undefined,
        authorization: [],
    };
    const builder = {
        required() {
            if (_meta.lastInvokedMethod === 'array') {
                data.arrayRequired = true;
            }
            else {
                data.required = true;
            }
            _meta.lastInvokedMethod = 'required';
            return this;
        },
        array() {
            data.array = true;
            _meta.lastInvokedMethod = 'array';
            return this;
        },
        default(val) {
            data.default = typeof val === 'undefined' ? exports.__generated : val;
            _meta.lastInvokedMethod = 'default';
            return this;
        },
        authorization(callback) {
            const { resource: _, ...rest } = Authorization_1.allow;
            const rules = callback(rest);
            data.authorization = Array.isArray(rules) ? rules : [rules];
            _meta.lastInvokedMethod = 'authorization';
            return this;
        },
        ...(0, util_1.brand)(brandName),
    };
    // this double cast gives us a Subtyping Constraint i.e., hides `data` from the public API,
    // but makes it available internally when needed
    return { ...builder, data };
}
/**
 * A unique identifier scalar type. This scalar is serialized like a String but isn't meant to be human-readable.
 * If not specified on create operations, a ULID will be auto-generated service-side.
 * @returns ID field definition
 */
function id() {
    return _field(ModelFieldType.Id);
}
exports.id = id;
/**
 * A string scalar type that is represented server-side as a UTF-8 character sequence.
 * @returns string field definition
 */
function string() {
    return _field(ModelFieldType.String);
}
exports.string = string;
/**
 * An integer scalar type with a supported value range between -(2^31) and 2^31-1.
 * @returns integer field definition
 */
function integer() {
    return _field(ModelFieldType.Integer);
}
exports.integer = integer;
/**
 * A float scalar type following represented server-side as an IEEE 754 floating point value.
 * @returns float field definition
 */
function float() {
    return _field(ModelFieldType.Float);
}
exports.float = float;
/**
 * A boolean scalar type that can be either true or false.
 * @returns boolean field definition
 */
function boolean() {
    return _field(ModelFieldType.Boolean);
}
exports.boolean = boolean;
/**
 * A date scalar type that is represented server-side as an extended ISO 8601 date string in the format `YYYY-MM-DD`.
 * @returns date field definition
 */
function date() {
    return _field(ModelFieldType.Date);
}
exports.date = date;
/**
 * A time scalar type that is represented server-side as an extended ISO 8601 time string in the format `hh:mm:ss.sss`.
 * @returns time field definition
 */
function time() {
    return _field(ModelFieldType.Time);
}
exports.time = time;
/**
 * A date time scalar type that is represented server-side as an extended ISO 8601 date and time string in the format `YYYY-MM-DDThh:mm:ss.sssZ`.
 * @returns datetime field definition
 */
function datetime() {
    return _field(ModelFieldType.DateTime);
}
exports.datetime = datetime;
/**
 * A timestamp scalar type that is represented by an integer value of the number of seconds before or after `1970-01-01-T00:00Z`.
 * @returns timestamp field definition
 */
function timestamp() {
    return _field(ModelFieldType.Timestamp);
}
exports.timestamp = timestamp;
/**
 * An email scalar type that is represented server-side in the format `local-part@domain-part` as defined by RFC 822.
 * @returns email field definition
 */
function email() {
    return _field(ModelFieldType.Email);
}
exports.email = email;
/**
 * A JSON scalar type that is automatically parsed and loaded server-side as maps, lists, or scalar values
 * rather than as the literal input strings.
 * @returns JSON field definition
 */
function json() {
    return _field(ModelFieldType.JSON);
}
exports.json = json;
/**
 * A phone number scalar type thas is stored as a string server-side. Phone numbers can contain either spaces
 * or hyphens to separate digit groups. Phone numbers without a country code are assumed to be US/North American numbers adhering
 * to the North American Numbering Plan.
 * @returns phone number field definition
 */
function phone() {
    return _field(ModelFieldType.Phone);
}
exports.phone = phone;
/**
 * A URL scalar type as defined by RFC 1738. For example, https://www.amazon.com/dp/B000NZW3KC/ or mailto:example@example.com.
 * URLs must contain a schema (http, mailto) and can't contain two forward slashes (//) in the path part.
 * @returns URL field definition
 */
function url() {
    return _field(ModelFieldType.Url);
}
exports.url = url;
/**
 * A valid IPv4 or IPv6 address scalar type. IPv4 addresses are expected in quad-dotted notation (123.12.34.56). IPv6 addresses
 * are expected in non-bracketed, colon-separated format (1a2b:3c4b:ðŸ”¢4567). You can include an optional CIDR suffix (123.45.67.89/16)
 * to indicate subnet mask.
 * @returns IP address field definition
 */
function ipAddress() {
    return _field(ModelFieldType.IPAddress);
}
exports.ipAddress = ipAddress;
//# sourceMappingURL=ModelField.js.map
