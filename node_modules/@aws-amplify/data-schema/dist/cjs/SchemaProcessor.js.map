{"version":3,"file":"SchemaProcessor.js","sources":["../../src/SchemaProcessor.ts"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.processSchema = void 0;\nconst tslib_1 = require(\"tslib\");\nconst ModelField_1 = require(\"./ModelField\");\nconst ModelRelationshipField_1 = require(\"./ModelRelationshipField\");\nconst Authorization_1 = require(\"./Authorization\");\nconst CustomOperation_1 = require(\"./CustomOperation\");\nconst util_1 = require(\"./util\");\nconst Handler_1 = require(\"./Handler\");\nconst os = tslib_1.__importStar(require(\"os\"));\nconst path = tslib_1.__importStar(require(\"path\"));\nconst Brand_1 = require(\"./util/Brand\");\nconst ConversationType_1 = require(\"./ai/ConversationType\");\nconst ConversationSchemaTypes_1 = require(\"./ai/ConversationSchemaTypes\");\nfunction isInternalModel(model) {\n    if (model.data &&\n        !isCustomType(model) &&\n        !isCustomOperation(model)) {\n        return true;\n    }\n    return false;\n}\nfunction isEnumType(data) {\n    if (data?.type === 'enum') {\n        return true;\n    }\n    return false;\n}\nfunction isCustomType(data) {\n    if (data?.data?.type === 'customType') {\n        return true;\n    }\n    return false;\n}\nfunction isConversationRoute(type) {\n    return (0, util_1.getBrand)(type) === ConversationType_1.brandName;\n}\nfunction isGenerationInput(input) {\n    return Boolean(input?.aiModel && input?.systemPrompt);\n}\nfunction isCustomOperation(type) {\n    if (CustomOperation_1.CustomOperationNames.includes(type?.data?.typeName)) {\n        return true;\n    }\n    return false;\n}\nfunction isModelFieldDef(data) {\n    return data?.fieldType === 'model';\n}\nfunction isScalarFieldDef(data) {\n    return data?.fieldType !== 'model';\n}\nfunction isRefFieldDef(data) {\n    return data?.type === 'ref';\n}\nfunction isModelField(field) {\n    return isModelFieldDef(field?.data);\n}\nfunction dataSourceIsRef(dataSource) {\n    return (typeof dataSource !== 'string' &&\n        dataSource?.data &&\n        dataSource.data.type === 'ref');\n}\nfunction isScalarField(field) {\n    return isScalarFieldDef(field?.data);\n}\nfunction isRefField(field) {\n    return isRefFieldDef(field?.data);\n}\nfunction scalarFieldToGql(fieldDef, identifier, secondaryIndexes = []) {\n    const { fieldType, required, array, arrayRequired, default: _default, } = fieldDef;\n    let field = fieldType;\n    if (identifier !== undefined) {\n        field += '!';\n        if (identifier.length > 1) {\n            const [_pk, ...sk] = identifier;\n            field += ` @primaryKey(sortKeyFields: [${sk\n                .map((sk) => `\"${sk}\"`)\n                .join(', ')}])`;\n        }\n        else {\n            field += ' @primaryKey';\n        }\n        for (const index of secondaryIndexes) {\n            field += ` ${index}`;\n        }\n        return field;\n    }\n    if (required === true) {\n        field += '!';\n    }\n    if (array) {\n        field = `[${field}]`;\n        if (arrayRequired === true) {\n            field += '!';\n        }\n    }\n    if (_default === ModelField_1.__generated) {\n        field += ` @default`;\n    }\n    else if (_default !== undefined) {\n        field += ` @default(value: \"${_default?.toString()}\")`;\n    }\n    for (const index of secondaryIndexes) {\n        field += ` ${index}`;\n    }\n    return field;\n}\nfunction modelFieldToGql(fieldDef) {\n    const { type, relatedModel, array, valueRequired, arrayRequired, references, } = fieldDef;\n    let field = relatedModel;\n    if (valueRequired === true) {\n        field += '!';\n    }\n    if (array) {\n        field = `[${field}]`;\n    }\n    if (arrayRequired === true) {\n        field += '!';\n    }\n    if (references && Array.isArray(references) && references.length > 0) {\n        field += ` @${type}(references: [${references.map((s) => `\"${String(s)}\"`)}])`;\n    }\n    else {\n        field += ` @${type}`;\n    }\n    return field;\n}\nfunction refFieldToGql(fieldDef, secondaryIndexes = []) {\n    const { link, valueRequired, array, arrayRequired } = fieldDef;\n    let field = link;\n    if (valueRequired === true) {\n        field += '!';\n    }\n    if (array === true) {\n        field = `[${field}]`;\n    }\n    if (arrayRequired === true) {\n        field += '!';\n    }\n    for (const index of secondaryIndexes) {\n        field += ` ${index}`;\n    }\n    return field;\n}\nfunction enumFieldToGql(enumName, secondaryIndexes = []) {\n    let field = enumName;\n    for (const index of secondaryIndexes) {\n        field += ` ${index}`;\n    }\n    return field;\n}\nfunction transformFunctionHandler(handlers, functionFieldName) {\n    let gqlHandlerContent = '';\n    const lambdaFunctionDefinition = {};\n    handlers.forEach((handler, idx) => {\n        const handlerData = (0, Handler_1.getHandlerData)(handler);\n        if (typeof handlerData.handler === 'string') {\n            gqlHandlerContent += `@function(name: \"${handlerData.handler}\") `;\n        }\n        else if (typeof handlerData.handler.getInstance === 'function') {\n            const fnName = `Fn${capitalize(functionFieldName)}${idx === 0 ? '' : `${idx + 1}`}`;\n            lambdaFunctionDefinition[fnName] = handlerData.handler;\n            const invocationTypeArg = handlerData.invocationType === 'Event'\n                ? ', invocationType: Event)'\n                : ')';\n            gqlHandlerContent += `@function(name: \"${fnName}\"${invocationTypeArg} `;\n        }\n        else {\n            throw new Error(`Invalid value specified for ${functionFieldName} handler.function(). Expected: defineFunction or string.`);\n        }\n    });\n    return {\n        gqlHandlerContent,\n        lambdaFunctionDefinition,\n    };\n}\nfunction customOperationToGql(typeName, typeDef, authorization, isCustom = false, databaseType, getRefType) {\n    const { arguments: fieldArgs, typeName: opType, returnType, handlers, subscriptionSource, } = typeDef.data;\n    let callSignature = typeName;\n    const implicitTypes = [];\n    // When Custom Operations are defined with a Custom Type return type,\n    // the Custom Type inherits the operation's auth rules\n    let customTypeAuthRules = undefined;\n    const { authString } = isCustom\n        ? mapToNativeAppSyncAuthDirectives(authorization, true)\n        : calculateAuth(authorization);\n    /**\n     *\n     * @param returnType The return type from the `data` field of a customer operation.\n     * @param refererTypeName The type the refers {@link returnType} by `a.ref()`.\n     * @param shouldAddCustomTypeToImplicitTypes A flag indicates wether it should push\n     * the return type resolved CustomType to the `implicitTypes` list.\n     * @returns\n     */\n    const resolveReturnTypeNameFromReturnType = (returnType, { refererTypeName, shouldAddCustomTypeToImplicitTypes = true, }) => {\n        if (isRefField(returnType)) {\n            const { type } = getRefType(returnType.data.link, typeName);\n            if (type === 'CustomType') {\n                customTypeAuthRules = {\n                    typeName: returnType.data.link,\n                    authRules: authorization,\n                };\n            }\n            return refFieldToGql(returnType?.data);\n        }\n        else if (isCustomType(returnType)) {\n            const returnTypeName = `${capitalize(refererTypeName)}ReturnType`;\n            if (shouldAddCustomTypeToImplicitTypes) {\n                customTypeAuthRules = {\n                    typeName: returnTypeName,\n                    authRules: authorization,\n                };\n                implicitTypes.push([returnTypeName, returnType]);\n            }\n            return returnTypeName;\n        }\n        else if (isEnumType(returnType)) {\n            const returnTypeName = `${capitalize(refererTypeName)}ReturnType`;\n            implicitTypes.push([returnTypeName, returnType]);\n            return returnTypeName;\n        }\n        else if (isScalarField(returnType)) {\n            return scalarFieldToGql(returnType?.data);\n        }\n        else {\n            throw new Error(`Unrecognized return type on ${typeName}`);\n        }\n    };\n    let returnTypeName;\n    if (opType === 'Subscription' && returnType === null) {\n        // up to this point, we've validated that each subscription resource resolves\n        // the same return type, so it's safe to use subscriptionSource[0] here.\n        const { type, def } = getRefType(subscriptionSource[0].data.link, typeName);\n        if (type === 'CustomOperation') {\n            returnTypeName = resolveReturnTypeNameFromReturnType(def.data.returnType, {\n                refererTypeName: subscriptionSource[0].data.link,\n                shouldAddCustomTypeToImplicitTypes: false,\n            });\n        }\n        else {\n            returnTypeName = refFieldToGql(subscriptionSource[0].data);\n        }\n    }\n    else {\n        returnTypeName = resolveReturnTypeNameFromReturnType(returnType, {\n            refererTypeName: typeName,\n        });\n    }\n    if (Object.keys(fieldArgs).length > 0) {\n        const { gqlFields, implicitTypes: implied } = processFields(typeName, fieldArgs, {}, {});\n        callSignature += `(${gqlFields.join(', ')})`;\n        implicitTypes.push(...implied);\n    }\n    const handler = handlers && handlers[0];\n    const brand = handler && (0, util_1.getBrand)(handler);\n    let gqlHandlerContent = '';\n    let lambdaFunctionDefinition = {};\n    let customSqlDataSourceStrategy;\n    if (isFunctionHandler(handlers)) {\n        ({ gqlHandlerContent, lambdaFunctionDefinition } = transformFunctionHandler(handlers, typeName));\n    }\n    else if (databaseType === 'sql' && handler && brand === 'inlineSql') {\n        gqlHandlerContent = `@sql(statement: ${escapeGraphQlString(String((0, Handler_1.getHandlerData)(handler)))}) `;\n        customSqlDataSourceStrategy = {\n            typeName: opType,\n            fieldName: typeName,\n        };\n    }\n    else if (isSqlReferenceHandler(handlers)) {\n        const handlerData = (0, Handler_1.getHandlerData)(handlers[0]);\n        const entry = resolveEntryPath(handlerData, 'Could not determine import path to construct absolute code path for sql reference handler. Consider using an absolute path instead.');\n        const reference = typeof entry === 'string' ? entry : entry.relativePath;\n        customSqlDataSourceStrategy = {\n            typeName: opType,\n            fieldName: typeName,\n            entry,\n        };\n        gqlHandlerContent = `@sql(reference: \"${reference}\") `;\n    }\n    if (opType === 'Subscription') {\n        const subscriptionSources = subscriptionSource\n            .flatMap((source) => {\n            const refTarget = source.data.link;\n            const { type } = getRefType(refTarget, typeName);\n            if (type === 'CustomOperation') {\n                return refTarget;\n            }\n            if (type === 'Model') {\n                return source.data.mutationOperations.map(\n                // capitalize explicitly in case customer used lowercase model name\n                (op) => `${op}${capitalize(refTarget)}`);\n            }\n        })\n            .join('\", \"');\n        gqlHandlerContent += `@aws_subscribe(mutations: [\"${subscriptionSources}\"]) `;\n    }\n    if (opType === 'Generation') {\n        if (!isGenerationInput(typeDef.data.input)) {\n            throw new Error(`Invalid Generation Route definition. A Generation Route must include a valid input. ${typeName} has an invalid or no input defined.`);\n        }\n        const { aiModel, systemPrompt, inferenceConfiguration } = typeDef.data.input;\n        // This is done to escape newlines in potentially multi-line system prompts\n        // e.g.\n        // generateStuff: a.generation({\n        //   aiModel: a.ai.model('Claude 3 Haiku'),\n        //   systemPrompt: `Generate a haiku\n        //   make it multiline`,\n        // }),\n        //\n        // It doesn't affect non multi-line string inputs for system prompts\n        const escapedSystemPrompt = systemPrompt.replace(/\\r?\\n/g, '\\\\n');\n        const inferenceConfigurationEntries = Object.entries(inferenceConfiguration ?? {});\n        const inferenceConfigurationGql = inferenceConfigurationEntries.length > 0\n            ? `, inferenceConfiguration: { ${inferenceConfigurationEntries\n                .map(([key, value]) => `${key}: ${value}`)\n                .join(', ')} }`\n            : '';\n        gqlHandlerContent += `@generation(aiModel: \"${aiModel.resourcePath}\", systemPrompt: \"${escapedSystemPrompt}\"${inferenceConfigurationGql}) `;\n    }\n    const gqlField = `${callSignature}: ${returnTypeName} ${gqlHandlerContent}${authString}`;\n    return {\n        gqlField,\n        implicitTypes: implicitTypes,\n        customTypeAuthRules,\n        lambdaFunctionDefinition,\n        customSqlDataSourceStrategy,\n    };\n}\n/**\n * Escape a string that will be used inside of a graphql string.\n * @param str The input string to be escaped\n * @returns The string with special charactars escaped\n */\nfunction escapeGraphQlString(str) {\n    return JSON.stringify(str);\n}\n/**\n * AWS AppSync scalars that are stored as strings in the data source\n */\nconst stringFieldTypes = {\n    ID: true,\n    String: true,\n    AWSDate: true,\n    AWSTime: true,\n    AWSDateTime: true,\n    AWSEmail: true,\n    AWSPhone: true,\n    AWSURL: true,\n    AWSIPAddress: true,\n};\n/**\n * Normalize string-compatible field types for comparison\n */\nconst normalizeStringFieldTypes = (fieldType) => {\n    if (fieldType in stringFieldTypes) {\n        return ModelField_1.ModelFieldType.String;\n    }\n    return fieldType;\n};\n/**\n * Tests whether two ModelField definitions are in conflict.\n *\n * This is a shallow check intended to catch conflicts between defined fields\n * and fields implied by authorization rules. Hence, it only compares type\n * and plurality.\n *\n * @param left\n * @param right\n * @returns\n */\nfunction areConflicting(left, right) {\n    const leftData = left.data;\n    const rightData = right.data;\n    // `array` and `fieldType` are the only props we care about for this comparison, because the others\n    // (required, arrayRequired, etc) are not specified on auth or FK directives.\n    if (leftData.array !== rightData.array) {\n        return true;\n    }\n    // Convert \"string-compatible\" field types to `String` for the sake of this comparison\n    //\n    // E.g. if a customer has an explicit a.id() field that they're referencing in an allow.ownerDefinedIn rule\n    // we treat ID and String as equivalent/non-conflicting\n    if (normalizeStringFieldTypes(leftData.fieldType) !==\n        normalizeStringFieldTypes(rightData.fieldType)) {\n        return true;\n    }\n    return false;\n}\n/**\n * Merges one field defition object onto an existing one, performing\n * validation (conflict detection) along the way.\n *\n * @param existing An existing field map\n * @param additions A field map to merge in\n */\nfunction addFields(existing, additions) {\n    for (const [k, addition] of Object.entries(additions)) {\n        if (!existing[k]) {\n            existing[k] = addition;\n        }\n        else if (areConflicting(existing[k], addition)) {\n            throw new Error(`Field ${k} defined twice with conflicting definitions.`);\n        }\n        else {\n            // fields are defined on both sides, but match.\n        }\n    }\n}\n/**\n * Validate that no implicit fields are used by the model definition\n *\n * @param existing An existing field map\n * @param implicitFields A field map inferred from other schema usage\n *\n * @throws An error when an undefined field is used or when a field is used in a way that conflicts with its generated definition\n */\nfunction validateStaticFields(existing, implicitFields) {\n    if (implicitFields === undefined) {\n        return;\n    }\n    for (const [k, field] of Object.entries(implicitFields)) {\n        if (!existing[k]) {\n            throw new Error(`Field ${k} isn't defined.`);\n        }\n        else if (areConflicting(existing[k], field)) {\n            throw new Error(`Field ${k} defined twice with conflicting definitions.`);\n        }\n    }\n}\n/**\n * Validate that no implicit fields conflict with explicitly defined fields.\n *\n * @param existing An existing field map\n * @param implicitFields A field map inferred from other schema usage\n *\n * @throws An error when an undefined field is used or when a field is used in a way that conflicts with its generated definition\n */\nfunction validateImpliedFields(existing, implicitFields) {\n    if (implicitFields === undefined) {\n        return;\n    }\n    for (const [k, field] of Object.entries(implicitFields)) {\n        if (existing[k] && areConflicting(existing[k], field)) {\n            throw new Error(`Implicit field ${k} conflicts with the explicit field definition.`);\n        }\n    }\n}\nfunction validateRefUseCases(referrerName, referrerType, fields, getRefType) {\n    const check = (fieldName, refLink, targetType) => {\n        const { def } = getRefType(refLink, referrerName);\n        if (isInternalModel(def)) {\n            throw new Error(`Cannot use \\`.ref()\\` to refer a model from a \\`${targetType}\\`. Field \\`${fieldName}\\` of \\`${referrerName}\\` refers to model \\`${refLink}\\``);\n        }\n    };\n    for (const [fieldName, field] of Object.entries(fields)) {\n        if (isRefField(field)) {\n            check(fieldName, field.data.link, referrerType === 'customType' ? 'custom type' : 'model');\n        }\n    }\n}\n/**\n * Given a list of authorization rules, produces a set of the implied owner and/or\n * group fields, along with the associated graphql `@auth` string directive.\n *\n * This is intended to be called for each model and field to collect the implied\n * fields and directives from that individual \"item's\" auth rules.\n *\n * The computed directives are intended to be appended to the graphql field definition.\n *\n * The computed fields will be used to confirm no conflicts between explicit field definitions\n * and implicit auth fields.\n *\n * @param authorization A list of authorization rules.\n * @returns\n */\nfunction calculateAuth(authorization) {\n    const authFields = {};\n    const rules = [];\n    for (const entry of authorization) {\n        const rule = (0, Authorization_1.accessData)(entry);\n        const ruleParts = [];\n        if (rule.strategy) {\n            ruleParts.push([`allow: ${rule.strategy}`]);\n        }\n        else {\n            return {\n                authFields,\n                authString: '',\n            };\n        }\n        if (rule.provider) {\n            // identityPool maps to iam in the transform\n            const provider = rule.provider === 'identityPool' ? 'iam' : rule.provider;\n            ruleParts.push(`provider: ${provider}`);\n        }\n        if (rule.operations) {\n            ruleParts.push(`operations: [${rule.operations.join(', ')}]`);\n        }\n        if (rule.groupOrOwnerField) {\n            // directive attribute, depending whether it's owner or group auth\n            if (rule.strategy === 'groups') {\n                // does this need to be escaped?\n                ruleParts.push(`groupsField: \"${rule.groupOrOwnerField}\"`);\n            }\n            else {\n                // does this need to be escaped?\n                ruleParts.push(`ownerField: \"${rule.groupOrOwnerField}\"`);\n            }\n            // model field dep, type of which depends on whether multiple owner/group\n            // is required.\n            if (rule.multiOwner) {\n                addFields(authFields, { [rule.groupOrOwnerField]: (0, ModelField_1.string)().array() });\n            }\n            else {\n                addFields(authFields, { [rule.groupOrOwnerField]: (0, ModelField_1.string)() });\n            }\n        }\n        if (rule.groups) {\n            // does `group` need to be escaped?\n            ruleParts.push(`groups: [${rule.groups.map((group) => `\"${group}\"`).join(', ')}]`);\n        }\n        // identityClaim\n        if (rule.identityClaim) {\n            // does this need to be escaped?\n            ruleParts.push(`identityClaim: \"${rule.identityClaim}\"`);\n        }\n        // groupClaim\n        if (rule.groupClaim) {\n            // does this need to be escaped?\n            ruleParts.push(`groupClaim: \"${rule.groupClaim}\"`);\n        }\n        rules.push(`{${ruleParts.join(', ')}}`);\n    }\n    const authString = rules.length > 0 ? `@auth(rules: [${rules.join(',\\n  ')}])` : '';\n    return { authString, authFields };\n}\nfunction validateCustomHandlerAuthRule(rule) {\n    if (rule.groups && rule.provider === 'oidc') {\n        throw new Error('OIDC group auth is not supported with a.handler.custom');\n    }\n    // not currently supported with handler.custom (JS Resolvers), but will be in the future\n    if (rule.provider === 'identityPool' || rule.provider === 'iam') {\n        throw new Error(\"identityPool-based auth (allow.guest() and allow.authenticated('identityPool')) is not supported with a.handler.custom\");\n    }\n}\nfunction getAppSyncAuthDirectiveFromRule(rule) {\n    const strategyDict = {\n        public: {\n            default: '@aws_api_key',\n            apiKey: '@aws_api_key',\n            iam: '@aws_iam',\n            identityPool: '@aws_iam',\n        },\n        private: {\n            default: '@aws_cognito_user_pools',\n            userPools: '@aws_cognito_user_pools',\n            oidc: '@aws_oidc',\n            iam: '@aws_iam',\n            identityPool: '@aws_iam',\n        },\n        groups: {\n            default: '@aws_cognito_user_pools',\n            userPools: '@aws_cognito_user_pools',\n        },\n        custom: {\n            default: '@aws_lambda',\n            function: '@aws_lambda',\n        },\n    };\n    const stratProviders = strategyDict[rule.strategy];\n    if (stratProviders === undefined) {\n        throw new Error(`Unsupported auth strategy for custom handlers: ${rule.strategy}`);\n    }\n    const provider = rule.provider || 'default';\n    const stratProvider = stratProviders[provider];\n    if (stratProvider === undefined) {\n        throw new Error(`Unsupported provider for custom handlers: ${rule.provider}`);\n    }\n    return stratProvider;\n}\nfunction mapToNativeAppSyncAuthDirectives(authorization, isCustomHandler) {\n    const rules = new Set();\n    for (const entry of authorization) {\n        const rule = (0, Authorization_1.accessData)(entry);\n        isCustomHandler && validateCustomHandlerAuthRule(rule);\n        const provider = getAppSyncAuthDirectiveFromRule(rule);\n        if (rule.groups) {\n            // example: (cognito_groups: [\"Bloggers\", \"Readers\"])\n            rules.add(`${provider}(cognito_groups: [${rule.groups\n                .map((group) => `\"${group}\"`)\n                .join(', ')}])`);\n        }\n        else {\n            rules.add(provider);\n        }\n    }\n    const authString = [...rules].join(' ');\n    return { authString };\n}\nfunction capitalize(s) {\n    return `${s[0].toUpperCase()}${s.slice(1)}`;\n}\nfunction processFieldLevelAuthRules(fields, authFields) {\n    const fieldLevelAuthRules = {};\n    for (const [fieldName, fieldDef] of Object.entries(fields)) {\n        const fieldAuth = fieldDef?.data?.authorization || [];\n        const { authString, authFields: fieldAuthField } = calculateAuth(fieldAuth);\n        if (authString)\n            fieldLevelAuthRules[fieldName] = authString;\n        if (fieldAuthField) {\n            addFields(authFields, fieldAuthField);\n        }\n    }\n    return fieldLevelAuthRules;\n}\nfunction processFields(typeName, fields, impliedFields, fieldLevelAuthRules, identifier, partitionKey, secondaryIndexes = {}) {\n    const gqlFields = [];\n    // stores nested, field-level type definitions (custom types and enums)\n    // the need to be hoisted to top-level schema types and processed accordingly\n    const implicitTypes = [];\n    validateImpliedFields(fields, impliedFields);\n    for (const [fieldName, fieldDef] of Object.entries(fields)) {\n        const fieldAuth = fieldLevelAuthRules[fieldName]\n            ? ` ${fieldLevelAuthRules[fieldName]}`\n            : '';\n        if (isModelField(fieldDef)) {\n            gqlFields.push(`${fieldName}: ${modelFieldToGql(fieldDef.data)}${fieldAuth}`);\n        }\n        else if (isScalarField(fieldDef)) {\n            if (fieldName === partitionKey) {\n                gqlFields.push(`${fieldName}: ${scalarFieldToGql(fieldDef.data, identifier, secondaryIndexes[fieldName])}${fieldAuth}`);\n            }\n            else if (isRefField(fieldDef)) {\n                gqlFields.push(`${fieldName}: ${refFieldToGql(fieldDef.data, secondaryIndexes[fieldName])}${fieldAuth}`);\n            }\n            else if (isEnumType(fieldDef)) {\n                // The inline enum type name should be `<TypeName><FieldName>` to avoid\n                // enum type name conflicts\n                const enumName = `${capitalize(typeName)}${capitalize(fieldName)}`;\n                implicitTypes.push([enumName, fieldDef]);\n                gqlFields.push(`${fieldName}: ${enumFieldToGql(enumName, secondaryIndexes[fieldName])}`);\n            }\n            else if (isCustomType(fieldDef)) {\n                // The inline CustomType name should be `<TypeName><FieldName>` to avoid\n                // CustomType name conflicts\n                const customTypeName = `${capitalize(typeName)}${capitalize(fieldName)}`;\n                implicitTypes.push([customTypeName, fieldDef]);\n                gqlFields.push(`${fieldName}: ${customTypeName}`);\n            }\n            else {\n                gqlFields.push(`${fieldName}: ${scalarFieldToGql(fieldDef.data, undefined, secondaryIndexes[fieldName])}${fieldAuth}`);\n            }\n        }\n        else {\n            throw new Error(`Unexpected field definition: ${fieldDef}`);\n        }\n    }\n    return { gqlFields, implicitTypes };\n}\n/**\n *\n * @param pk - partition key field name\n * @param sk - (optional) array of sort key field names\n * @returns default query field name\n */\nconst secondaryIndexDefaultQueryField = (modelName, pk, sk) => {\n    const skName = sk?.length ? 'And' + sk?.map(capitalize).join('And') : '';\n    const queryField = `list${capitalize(modelName)}By${capitalize(pk)}${skName}`;\n    return queryField;\n};\n/**\n * Given InternalModelIndexType[] returns a map where the key is the model field to be annotated with an @index directive\n * and the value is an array of transformed Amplify @index directives with all supplied attributes\n */\nconst transformedSecondaryIndexesForModel = (modelName, secondaryIndexes, modelFields, getRefType) => {\n    const indexDirectiveWithAttributes = (partitionKey, sortKeys, indexName, queryField) => {\n        for (const keyName of [partitionKey, ...sortKeys]) {\n            const field = modelFields[keyName];\n            if (isRefField(field)) {\n                const { def } = getRefType(field.data.link, modelName);\n                if (!isEnumType(def)) {\n                    throw new Error(`The ref field \\`${keyName}\\` used in the secondary index of \\`${modelName}\\` should refer to an enum type. \\`${field.data.link}\\` is not a enum type.`);\n                }\n            }\n        }\n        if (!sortKeys.length && !indexName && !queryField) {\n            return `@index(queryField: \"${secondaryIndexDefaultQueryField(modelName, partitionKey)}\")`;\n        }\n        const attributes = [];\n        if (indexName) {\n            attributes.push(`name: \"${indexName}\"`);\n        }\n        if (sortKeys.length) {\n            attributes.push(`sortKeyFields: [${sortKeys.map((sk) => `\"${sk}\"`).join(', ')}]`);\n        }\n        if (queryField) {\n            attributes.push(`queryField: \"${queryField}\"`);\n        }\n        else {\n            attributes.push(`queryField: \"${secondaryIndexDefaultQueryField(modelName, partitionKey, sortKeys)}\"`);\n        }\n        return `@index(${attributes.join(', ')})`;\n    };\n    return secondaryIndexes.reduce((acc, { data: { partitionKey, sortKeys, indexName, queryField } }) => {\n        acc[partitionKey] = acc[partitionKey] || [];\n        acc[partitionKey].push(indexDirectiveWithAttributes(partitionKey, sortKeys, indexName, queryField));\n        return acc;\n    }, {});\n};\nconst ruleIsResourceAuth = (authRule) => {\n    const data = (0, Authorization_1.accessSchemaData)(authRule);\n    return data.strategy === 'resource';\n};\n/**\n * Separates out lambda resource auth rules from remaining schema rules.\n *\n * @param authRules schema auth rules\n */\nconst extractFunctionSchemaAccess = (authRules) => {\n    const schemaAuth = [];\n    const functionSchemaAccess = [];\n    const defaultActions = [\n        'query',\n        'mutate',\n        'listen',\n    ];\n    for (const rule of authRules) {\n        if (ruleIsResourceAuth(rule)) {\n            const ruleData = (0, Authorization_1.accessSchemaData)(rule);\n            const fnAccess = {\n                resourceProvider: ruleData.resource,\n                actions: ruleData.operations || defaultActions,\n            };\n            functionSchemaAccess.push(fnAccess);\n        }\n        else {\n            schemaAuth.push(rule);\n        }\n    }\n    return { schemaAuth, functionSchemaAccess };\n};\n/**\n * Searches a schema and all related schemas (through `.combine()`) for the given type by name.\n *\n * @param schema\n * @param name\n * @returns\n */\nconst findCombinedSchemaType = (schema, name) => {\n    if (schema.context) {\n        for (const contextualSchema of schema.context.schemas) {\n            if (contextualSchema.data.types[name]) {\n                return contextualSchema.data.types[name];\n            }\n        }\n    }\n    else {\n        return schema.data.types[name];\n    }\n    return undefined;\n};\n/**\n * Returns a closure for retrieving reference type and definition from schema\n */\nconst getRefTypeForSchema = (schema) => {\n    const getRefType = (name, referrerName) => {\n        const typeDef = findCombinedSchemaType(schema, name);\n        if (typeDef === undefined) {\n            throw new Error(referrerName\n                ? `Invalid ref. ${referrerName} is referring to ${name} which is not defined in the schema`\n                : `Invalid ref. ${name} is not defined in the schema`);\n        }\n        if (isInternalModel(typeDef)) {\n            return { type: 'Model', def: typeDef };\n        }\n        if (isCustomOperation(typeDef)) {\n            return { type: 'CustomOperation', def: typeDef };\n        }\n        if (isCustomType(typeDef)) {\n            return { type: 'CustomType', def: typeDef };\n        }\n        if (isEnumType(typeDef)) {\n            return { type: 'Enum', def: typeDef };\n        }\n        throw new Error(referrerName\n            ? `Invalid ref. ${referrerName} is referring to ${name} which is neither a Model, Custom Operation, Custom Type, or Enum`\n            : `Invalid ref. ${name} is neither a Model, Custom Operation, Custom Type, or Enum`);\n    };\n    return getRefType;\n};\n/**\n * Sorts top-level schema types to where Custom Types are processed last\n * This allows us to accrue and then apply inherited auth rules for custom types from custom operations\n * that reference them in their return values\n */\nconst sortTopLevelTypes = (topLevelTypes) => {\n    return topLevelTypes.sort(([_typeNameA, typeDefA], [_typeNameB, typeDefB]) => {\n        if ((isCustomType(typeDefA) && isCustomType(typeDefB)) ||\n            (!isCustomType(typeDefA) && !isCustomType(typeDefB))) {\n            return 0;\n        }\n        else if (isCustomType(typeDefA) && !isCustomType(typeDefB)) {\n            return 1;\n        }\n        else {\n            return -1;\n        }\n    });\n};\n/**\n * Builds up dictionary of Custom Type name - array of inherited auth rules\n */\nconst mergeCustomTypeAuthRules = (existing, added) => {\n    if (!added)\n        return;\n    const { typeName, authRules } = added;\n    if (typeName in existing) {\n        existing[typeName] = [...existing[typeName], ...authRules];\n    }\n    else {\n        existing[typeName] = authRules;\n    }\n};\nconst schemaPreprocessor = (schema) => {\n    const gqlModels = [];\n    const customQueries = [];\n    const customMutations = [];\n    const customSubscriptions = [];\n    let shouldAddConversationTypes = false;\n    // Dict of auth rules to be applied to custom types\n    // Inherited from the auth configured on the custom operations that return these custom types\n    const customTypeInheritedAuthRules = {};\n    const jsFunctions = [];\n    const lambdaFunctions = {};\n    const customSqlDataSourceStrategies = [];\n    const databaseType = schema.data.configuration.database.engine === 'dynamodb'\n        ? 'dynamodb'\n        : 'sql';\n    const staticSchema = databaseType === 'sql';\n    // If the schema contains a custom operation with an async lambda handler,\n    // we need to add the EventInvocationResponse custom type to the schema.\n    // This is done here so that:\n    // - it only happens once per schema\n    // - downstream validation based on `getRefTypeForSchema` finds the EventInvocationResponse type\n    const containsAsyncLambdaCustomOperation = Object.entries(schema.data.types).find(([_, typeDef]) => {\n        return (isCustomOperation(typeDef) &&\n            finalHandlerIsAsyncFunctionHandler(typeDef.data.handlers));\n    });\n    if (containsAsyncLambdaCustomOperation) {\n        schema.data.types['EventInvocationResponse'] =\n            eventInvocationResponseCustomType;\n    }\n    const topLevelTypes = sortTopLevelTypes(Object.entries(schema.data.types));\n    const { schemaAuth, functionSchemaAccess } = extractFunctionSchemaAccess(schema.data.authorization);\n    const getRefType = getRefTypeForSchema(schema);\n    for (const [typeName, typeDef] of topLevelTypes) {\n        const mostRelevantAuthRules = typeDef.data?.authorization?.length > 0\n            ? typeDef.data.authorization\n            : schemaAuth;\n        if (!isInternalModel(typeDef)) {\n            if (isEnumType(typeDef)) {\n                if (typeDef.values.some((value) => /\\s/.test(value))) {\n                    throw new Error(`Values of the enum type ${typeName} should not contain any whitespace.`);\n                }\n                const enumType = `enum ${typeName} {\\n  ${typeDef.values.join('\\n  ')}\\n}`;\n                gqlModels.push(enumType);\n            }\n            else if (isCustomType(typeDef)) {\n                const fields = typeDef.data.fields;\n                validateRefUseCases(typeName, 'customType', fields, getRefType);\n                const fieldAuthApplicableFields = Object.fromEntries(Object.entries(fields).filter((pair) => isModelField(pair[1])));\n                let customAuth = '';\n                if (typeName in customTypeInheritedAuthRules) {\n                    const { authString } = mapToNativeAppSyncAuthDirectives(customTypeInheritedAuthRules[typeName], false);\n                    customAuth = authString;\n                }\n                const authFields = {};\n                const fieldLevelAuthRules = processFieldLevelAuthRules(fieldAuthApplicableFields, authFields);\n                const { gqlFields, implicitTypes } = processFields(typeName, fields, authFields, fieldLevelAuthRules);\n                topLevelTypes.push(...implicitTypes);\n                const joined = gqlFields.join('\\n  ');\n                const model = `type ${typeName} ${customAuth}\\n{\\n  ${joined}\\n}`;\n                gqlModels.push(model);\n            }\n            else if (isCustomOperation(typeDef)) {\n                // TODO: add generation route logic.\n                const { typeName: opType } = typeDef.data;\n                const { gqlField, implicitTypes, customTypeAuthRules, jsFunctionForField, lambdaFunctionDefinition, customSqlDataSourceStrategy, } = transformCustomOperations(typeDef, typeName, mostRelevantAuthRules, databaseType, getRefType);\n                topLevelTypes.push(...implicitTypes);\n                mergeCustomTypeAuthRules(customTypeInheritedAuthRules, customTypeAuthRules);\n                if (customTypeAuthRules) {\n                    const nestedCustomTypeNames = extractNestedCustomTypeNames(customTypeAuthRules, topLevelTypes, getRefType);\n                    for (const nestedCustomType of nestedCustomTypeNames) {\n                        mergeCustomTypeAuthRules(customTypeInheritedAuthRules, {\n                            typeName: nestedCustomType,\n                            authRules: customTypeAuthRules.authRules, // apply the same auth rules as the top-level custom type\n                        });\n                    }\n                }\n                Object.assign(lambdaFunctions, lambdaFunctionDefinition);\n                if (jsFunctionForField) {\n                    jsFunctions.push(jsFunctionForField);\n                }\n                if (customSqlDataSourceStrategy) {\n                    customSqlDataSourceStrategies.push(customSqlDataSourceStrategy);\n                }\n                switch (opType) {\n                    case 'Query':\n                    case 'Generation':\n                        customQueries.push(gqlField);\n                        break;\n                    case 'Mutation':\n                        customMutations.push(gqlField);\n                        break;\n                    case 'Subscription':\n                        customSubscriptions.push(gqlField);\n                        break;\n                    default:\n                        break;\n                }\n            }\n            else if (isConversationRoute(typeDef)) {\n                // TODO: add inferenceConfiguration values to directive.\n                const { field, functionHandler } = (0, ConversationSchemaTypes_1.createConversationField)(typeDef, typeName);\n                customMutations.push(field);\n                Object.assign(lambdaFunctions, functionHandler);\n                shouldAddConversationTypes = true;\n            }\n        }\n        else if (staticSchema) {\n            const fields = { ...typeDef.data.fields };\n            validateRefUseCases(typeName, 'model', fields, getRefType);\n            const identifier = typeDef.data.identifier;\n            const [partitionKey] = identifier;\n            const { authString, authFields } = calculateAuth(mostRelevantAuthRules);\n            const fieldLevelAuthRules = processFieldLevelAuthRules(fields, authFields);\n            validateStaticFields(fields, authFields);\n            const { gqlFields, implicitTypes } = processFields(typeName, fields, authFields, fieldLevelAuthRules, identifier, partitionKey);\n            topLevelTypes.push(...implicitTypes);\n            const joined = gqlFields.join('\\n  ');\n            const refersToString = typeDef.data.originalName\n                ? ` @refersTo(name: \"${typeDef.data.originalName}\")`\n                : '';\n            // TODO: update @model(timestamps: null) once a longer term solution gets\n            // determined.\n            //\n            // Context: SQL schema should not be automatically inserted with timestamp fields,\n            // passing (timestamps: null) to @model to suppress this behavior as a short\n            // term solution.\n            const model = `type ${typeName} @model(timestamps: null) ${authString}${refersToString}\\n{\\n  ${joined}\\n}`;\n            gqlModels.push(model);\n        }\n        else {\n            const fields = typeDef.data.fields;\n            validateRefUseCases(typeName, 'model', fields, getRefType);\n            const identifier = typeDef.data.identifier;\n            const [partitionKey] = identifier;\n            const transformedSecondaryIndexes = transformedSecondaryIndexesForModel(typeName, typeDef.data.secondaryIndexes, fields, getRefType);\n            const { authString, authFields } = calculateAuth(mostRelevantAuthRules);\n            if (authString == '') {\n                throw new Error(`Model \\`${typeName}\\` is missing authorization rules. Add global rules to the schema or ensure every model has its own rules.`);\n            }\n            const getInternalModel = (modelName, sourceName) => {\n                const model = getRefType(modelName, sourceName);\n                if (!isInternalModel(model.def)) {\n                    throw new Error(`Expected to find model type with name ${modelName}`);\n                }\n                return model.def;\n            };\n            validateRelationships(typeName, fields, getInternalModel);\n            const fieldLevelAuthRules = processFieldLevelAuthRules(fields, authFields);\n            const { gqlFields, implicitTypes } = processFields(typeName, fields, authFields, fieldLevelAuthRules, identifier, partitionKey, transformedSecondaryIndexes);\n            topLevelTypes.push(...implicitTypes);\n            const joined = gqlFields.join('\\n  ');\n            const modelAttrs = modelAttributesFromDisabledOps(typeDef.data.disabledOperations);\n            const modelDirective = modelAttrs ? `@model(${modelAttrs})` : '@model';\n            const model = `type ${typeName} ${modelDirective} ${authString}\\n{\\n  ${joined}\\n}`;\n            gqlModels.push(model);\n        }\n    }\n    const customOperations = {\n        queries: customQueries,\n        mutations: customMutations,\n        subscriptions: customSubscriptions,\n    };\n    gqlModels.push(...generateCustomOperationTypes(customOperations));\n    if (shouldAddConversationTypes) {\n        gqlModels.push(...ConversationSchemaTypes_1.conversationTypes);\n    }\n    const processedSchema = gqlModels.join('\\n\\n');\n    return {\n        schema: processedSchema,\n        jsFunctions,\n        functionSchemaAccess,\n        lambdaFunctions,\n        customSqlDataSourceStrategies,\n    };\n};\nfunction validateCustomOperations(typeDef, typeName, authRules, getRefType) {\n    const { handlers, typeName: opType, subscriptionSource } = typeDef.data;\n    const handlerConfigured = handlers?.length;\n    const authConfigured = authRules.length > 0;\n    if (opType !== 'Generation' &&\n        ((authConfigured && !handlerConfigured) ||\n            (handlerConfigured && !authConfigured))) {\n        // Deploying a custom operation with auth and no handler reference OR\n        // with a handler reference but no auth\n        // causes the CFN stack to reach an unrecoverable state. Ideally, this should be fixed\n        // in the CDK construct, but we're catching it early here as a stopgap\n        throw new Error(`Custom operation ${typeName} requires both an authorization rule and a handler reference`);\n    }\n    // Handlers must all be of the same type\n    if (handlers?.length) {\n        const configuredHandlers = new Set();\n        for (const handler of handlers) {\n            configuredHandlers.add((0, util_1.getBrand)(handler));\n        }\n        if (configuredHandlers.size > 1) {\n            configuredHandlers.delete('asyncFunctionHandler');\n            configuredHandlers.delete('functionHandler');\n            if (configuredHandlers.size > 0) {\n                const configuredHandlersStr = JSON.stringify(Array.from(configuredHandlers));\n                throw new Error(`Field handlers must be of the same type. ${typeName} has been configured with ${configuredHandlersStr}`);\n            }\n        }\n    }\n    if (typeDef.data.returnType === null &&\n        (opType === 'Query' || opType === 'Mutation' || opType === 'Generation')) {\n        // TODO: There should be a more elegant and readable way to handle this check.\n        // Maybe it's not even necessary anymore since we're the setting returnType in the handler() method.\n        if (!handlers ||\n            handlers.length === 0 ||\n            handlers[handlers.length - 1][Brand_1.brandSymbol] !== 'asyncFunctionHandler') {\n            const typeDescription = opType === 'Generation' ? 'Generation Route' : `Custom ${opType}`;\n            throw new Error(`Invalid ${typeDescription} definition. A ${typeDescription} must include a return type. ${typeName} has no return type specified.`);\n        }\n    }\n    if (opType !== 'Subscription' && subscriptionSource.length > 0) {\n        throw new Error(`The .for() modifier function can only be used with a custom subscription. ${typeName} is not a custom subscription.`);\n    }\n    if (opType === 'Subscription') {\n        if (subscriptionSource.length < 1) {\n            throw new Error(`${typeName} is missing a mutation source. Custom subscriptions must reference a mutation source via subscription().for(a.ref('ModelOrOperationName')) `);\n        }\n        let expectedReturnType;\n        for (const source of subscriptionSource) {\n            const sourceName = source.data.link;\n            const { type, def } = getRefType(sourceName, typeName);\n            if (type !== 'Model' && source.data.mutationOperations.length > 0) {\n                throw new Error(`Invalid subscription definition. .mutations() modifier can only be used with a Model ref. ${typeName} is referencing ${type}`);\n            }\n            let resolvedReturnType;\n            if (type === 'Model') {\n                if (source.data.mutationOperations.length === 0) {\n                    throw new Error(`Invalid subscription definition. .mutations() modifier must be used with a Model ref subscription source. ${typeName} is referencing ${sourceName} without specifying a mutation`);\n                }\n                else {\n                    resolvedReturnType = def;\n                }\n            }\n            if (type === 'CustomOperation') {\n                if (def.data.typeName !== 'Mutation') {\n                    throw new Error(`Invalid subscription definition. .for() can only reference a mutation. ${typeName} is referencing ${sourceName} which is a ${def.data.typeName}`);\n                }\n                else {\n                    const returnType = def.data.returnType;\n                    if (isRefField(returnType)) {\n                        ({ def: resolvedReturnType } = getRefType(returnType.data.link, typeName));\n                    }\n                    else {\n                        resolvedReturnType = returnType;\n                    }\n                }\n            }\n            expectedReturnType = expectedReturnType ?? resolvedReturnType;\n            // As the return types are resolved from the root `schema` object and they should\n            // not be mutated, we compare by references here.\n            if (expectedReturnType !== resolvedReturnType) {\n                throw new Error(`Invalid subscription definition. .for() can only reference resources that have the same return type. ${typeName} is referencing resources that have different return types.`);\n            }\n        }\n    }\n}\nconst isSqlReferenceHandler = (handler) => {\n    return Array.isArray(handler) && (0, util_1.getBrand)(handler[0]) === 'sqlReference';\n};\nconst isCustomHandler = (handler) => {\n    return Array.isArray(handler) && (0, util_1.getBrand)(handler[0]) === 'customHandler';\n};\nconst isFunctionHandler = (handler) => {\n    return (Array.isArray(handler) &&\n        ['functionHandler', 'asyncFunctionHandler'].includes((0, util_1.getBrand)(handler[0])));\n};\nconst finalHandlerIsAsyncFunctionHandler = (handler) => {\n    return (Array.isArray(handler) &&\n        (0, util_1.getBrand)(handler[handler.length - 1]) === 'asyncFunctionHandler');\n};\nconst normalizeDataSourceName = (dataSource) => {\n    // default data source\n    const noneDataSourceName = 'NONE_DS';\n    if (dataSource === undefined) {\n        return noneDataSourceName;\n    }\n    if (dataSourceIsRef(dataSource)) {\n        return `${dataSource.data.link}Table`;\n    }\n    return dataSource;\n};\nconst sanitizeStackTrace = (stackTrace) => {\n    // normalize EOL to \\n so that parsing is consistent across platforms\n    const normalizedStackTrace = stackTrace.replace(new RegExp(os.EOL), '\\n');\n    return (normalizedStackTrace\n        .split('\\n')\n        .map((line) => line.trim())\n        // filters out noise not relevant to the stack trace. All stack trace lines begin with 'at'\n        .filter((line) => line.startsWith('at')) || []);\n};\n// copied from the defineFunction path resolution impl:\n// https://github.com/aws-amplify/amplify-backend/blob/main/packages/backend-function/src/get_caller_directory.ts\nconst resolveEntryPath = (data, errorMessage) => {\n    if (path.isAbsolute(data.entry)) {\n        return data.entry;\n    }\n    if (!data.stack) {\n        throw new Error(errorMessage);\n    }\n    const stackTraceLines = sanitizeStackTrace(data.stack);\n    if (stackTraceLines.length < 2) {\n        throw new Error(errorMessage);\n    }\n    const stackTraceImportLine = stackTraceLines[1]; // the first entry is the file where the error was initialized (our code). The second entry is where the customer called our code which is what we are interested in\n    // if entry is relative, compute with respect to the caller directory\n    return { relativePath: data.entry, importLine: stackTraceImportLine };\n};\nconst handleCustom = (handlers, opType, typeName) => {\n    const transformedHandlers = handlers.map((handler) => {\n        const handlerData = (0, Handler_1.getHandlerData)(handler);\n        return {\n            dataSource: normalizeDataSourceName(handlerData.dataSource),\n            entry: resolveEntryPath(handlerData, 'Could not determine import path to construct absolute code path for custom handler. Consider using an absolute path instead.'),\n        };\n    });\n    const jsFn = {\n        typeName: opType,\n        fieldName: typeName,\n        handlers: transformedHandlers,\n    };\n    return jsFn;\n};\nconst eventInvocationResponseCustomType = {\n    data: {\n        fields: {\n            success: {\n                data: {\n                    fieldType: ModelField_1.ModelFieldType.Boolean,\n                    required: true,\n                    array: false,\n                    arrayRequired: false,\n                },\n            },\n        },\n        type: 'customType',\n    },\n};\nfunction transformCustomOperations(typeDef, typeName, authRules, databaseType, getRefType) {\n    const { typeName: opType, handlers } = typeDef.data;\n    let jsFunctionForField = undefined;\n    validateCustomOperations(typeDef, typeName, authRules, getRefType);\n    if (isCustomHandler(handlers)) {\n        jsFunctionForField = handleCustom(handlers, \n        // Generation routes should not have handlers\n        opType, typeName);\n    }\n    const isCustom = Boolean(jsFunctionForField);\n    const { gqlField, implicitTypes, customTypeAuthRules, lambdaFunctionDefinition, customSqlDataSourceStrategy, } = customOperationToGql(typeName, typeDef, authRules, isCustom, databaseType, getRefType);\n    return {\n        gqlField,\n        implicitTypes,\n        customTypeAuthRules,\n        jsFunctionForField,\n        lambdaFunctionDefinition,\n        customSqlDataSourceStrategy,\n    };\n}\nfunction generateCustomOperationTypes({ queries, mutations, subscriptions, }) {\n    const types = [];\n    if (mutations.length > 0) {\n        types.push(`type Mutation {\\n  ${mutations.join('\\n  ')}\\n}`);\n    }\n    if (queries.length > 0) {\n        types.push(`type Query {\\n  ${queries.join('\\n  ')}\\n}`);\n    }\n    if (subscriptions.length > 0) {\n        types.push(`type Subscription {\\n  ${subscriptions.join('\\n  ')}\\n}`);\n    }\n    return types;\n}\nfunction extractNestedCustomTypeNames(customTypeAuthRules, topLevelTypes, getRefType) {\n    if (!customTypeAuthRules) {\n        return [];\n    }\n    const [_, customTypeDef] = topLevelTypes.find(([topLevelTypeName]) => customTypeAuthRules.typeName === topLevelTypeName);\n    // traverse the custom type's fields and extract any nested custom type names.\n    // Those nested custom types also inherit the custom op's auth configuration.\n    // Supports both inline custom types and refs to custom types\n    const traverseCustomTypeFields = (name, typeDef, namesList = []) => {\n        const fields = typeDef.data.fields;\n        for (const [fieldName, fieldDef] of Object.entries(fields)) {\n            if (isCustomType(fieldDef)) {\n                const customTypeName = `${capitalize(name)}${capitalize(fieldName)}`;\n                namesList.push(customTypeName);\n                traverseCustomTypeFields(customTypeName, fieldDef, namesList);\n            }\n            else if (isRefField(fieldDef)) {\n                const refType = getRefType(fieldDef.data.link, name);\n                if (refType.type === 'CustomType') {\n                    namesList.push(fieldDef.data.link);\n                    traverseCustomTypeFields(fieldDef.data.link, refType.def, namesList);\n                }\n            }\n        }\n        return namesList;\n    };\n    const nestedCustomTypeNames = traverseCustomTypeFields(customTypeAuthRules.typeName, customTypeDef);\n    return nestedCustomTypeNames;\n}\n/**\n * Validates that defined relationships conform to the following rules.\n * - relationships are bidirectional\n *   - hasOne has a belongsTo counterpart\n *   - hasMany has a belongsTo counterpart\n *   - belongsTo has either a hasOne or hasMany counterpart\n * - both sides of a relationship have identical `references` defined.\n * - the `references` match the primary key of the parent model\n *   - references[0] is the primaryKey's partitionKey on the parent model\n *   - references[1...n] are the primaryKey's sortKey(s) on the parent model\n *   - types match (id / string / number)\n * - the `references` are fields defined on the child model\n *   - field names match the named `references` arguments\n *   - child model references fields types match those of the parent model's primaryKey\n * @param typeName source model's type name.\n * @param record map of field name to {@link ModelField}\n * @param getInternalModel given a model name, return an {@link InternalModel}\n */\nfunction validateRelationships(typeName, record, getInternalModel) {\n    for (const [name, field] of Object.entries(record)) {\n        // If the field's type is not a model, there's no relationship\n        // to evaluate and we can skip this iteration.\n        if (!isModelField(field)) {\n            continue;\n        }\n        // Create a structure representing the relationship for validation.\n        const relationship = getModelRelationship(typeName, { name: name, def: field.data }, getInternalModel);\n        // Validate that the references defined in the relationship follow the\n        // relationship definition rules.\n        validateRelationshipReferences(relationship);\n    }\n}\n/**\n * Helper function that describes the relationship of a given connection field for use in logging or error messages.\n *\n * `Parent.child: Child @hasMany(references: ['parentId'])`\n * -- or --\n * `Child.parent: Parent @belongsTo(references: ['parentId'])`\n * @param sourceField The {@link ConnectionField} to describe.\n * @param sourceModelName The name of the model within which the sourceField is defined.\n * @returns a 'string' describing the relationship\n */\nfunction describeConnectFieldRelationship(sourceField, sourceModelName) {\n    const associatedTypeDescription = sourceField.def.array\n        ? `[${sourceField.def.relatedModel}]`\n        : sourceField.def.relatedModel;\n    const referencesDescription = sourceField.def.references\n        .reduce((description, reference) => description + `'${reference}', `, 'references: [')\n        .slice(0, -2) + ']';\n    return `${sourceModelName}.${sourceField.name}: ${associatedTypeDescription} @${sourceField.def.type}(${referencesDescription})`;\n}\n/**\n * Validates that the types of child model's reference fields match the types of the parent model's identifier fields.\n * @param relationship The {@link ModelRelationship} to validate.\n */\nfunction validateRelationshipReferences(relationship) {\n    const { parent, parentConnectionField, child, childConnectionField, references, } = relationship;\n    const parentIdentifiers = getIndentifierTypes(parent);\n    const childReferenceTypes = [];\n    // Iterate through the model schema defined 'references' to find each matching field on the Related model.\n    // If a field by that name is not found, throw a validate error.\n    // Accumulate the ModelFieldType for each reference field to validate matching types below.\n    for (const reference of references) {\n        const relatedReferenceType = child.data.fields[reference]?.data\n            .fieldType;\n        // reference field on related type with name passed to references not found. Time to throw a validation error.\n        if (!relatedReferenceType) {\n            const errorMessage = `reference field '${reference}' must be defined on ${parentConnectionField.def.relatedModel}. ` +\n                describeConnectFieldRelationship(parentConnectionField, childConnectionField.def.relatedModel) +\n                ' <-> ' +\n                describeConnectFieldRelationship(childConnectionField, parentConnectionField.def.relatedModel);\n            throw new Error(errorMessage);\n        }\n        childReferenceTypes.push(relatedReferenceType);\n    }\n    if (parentIdentifiers.length !== childReferenceTypes.length) {\n        throw new Error(`The identifiers defined on ${childConnectionField.def.relatedModel} must match the reference fields defined on ${parentConnectionField.def.relatedModel}.\\n` +\n            `${parentIdentifiers.length} identifiers defined on ${childConnectionField.def.relatedModel}.\\n` +\n            `${childReferenceTypes.length} reference fields found on ${parentConnectionField.def.relatedModel}`);\n    }\n    const matchingModelFieldType = (a, b) => {\n        // `String` and `Id` are considered equal types for when comparing\n        // the child model's references fields with their counterparts within\n        // the parent model's identifier (parent key) fields.\n        const matching = [ModelField_1.ModelFieldType.Id, ModelField_1.ModelFieldType.String];\n        return a === b || (matching.includes(a) && matching.includes(b));\n    };\n    // Zip pairs of child model's reference field with corresponding parent model's identifier field.\n    // Confirm that the types match. If they don't, throw a validation error.\n    parentIdentifiers\n        .map((identifier, index) => [identifier, childReferenceTypes[index]])\n        .forEach(([parent, child]) => {\n        if (!matchingModelFieldType(parent, child)) {\n            throw new Error('Validate Error: types do not match');\n        }\n    });\n}\n/**\n * Relationship definitions require bi-directionality.\n * Use this to generate a `ModelRelationshipTypes[]` containing acceptable counterparts on the\n * associated model.\n *\n * Given {@link ModelRelationshipTypes.hasOne} or {@link ModelRelationshipTypes.hasOne} returns [{@link ModelRelationshipTypes.belongsTo}]\n * Given {@link ModelRelationshipTypes.belongsTo} returns [{@link ModelRelationshipTypes.hasOne}, {@link ModelRelationshipTypes.belongsTo}]\n *\n * @param relationshipType {@link ModelRelationshipTypes} defined on source model's connection field.\n * @returns possible counterpart {@link ModelRelationshipTypes} as `ModelRelationshipTypes[]`\n */\nfunction associatedRelationshipTypes(relationshipType) {\n    switch (relationshipType) {\n        case ModelRelationshipField_1.ModelRelationshipTypes.hasOne:\n        case ModelRelationshipField_1.ModelRelationshipTypes.hasMany:\n            return [ModelRelationshipField_1.ModelRelationshipTypes.belongsTo];\n        case ModelRelationshipField_1.ModelRelationshipTypes.belongsTo:\n            return [ModelRelationshipField_1.ModelRelationshipTypes.hasOne, ModelRelationshipField_1.ModelRelationshipTypes.hasMany];\n        default:\n            return []; // TODO: Remove this case on types are updated.\n    }\n}\n/**\n * Retrieves the types of the identifiers defined on a model.\n *\n * Note: if a field by the name `id` isn't found in the {@link InternalModel},\n * this assumes an implicitly generated identifier is used with the type.\n *\n * This function does not validate that a corresponding field exists for each of the\n * identifiers because this validation happens at compile time.\n * @param model {@link InternalModel} from which to retrieve identifier types.\n * @returns Array of {@link ModelFieldType} of the model's identifiers found.\n */\nfunction getIndentifierTypes(model) {\n    return model.data.identifier.flatMap((fieldName) => {\n        const field = model.data.fields[fieldName];\n        if (field) {\n            return [field.data.fieldType];\n        }\n        else if (fieldName === 'id') {\n            // implicity generated ID\n            return [ModelField_1.ModelFieldType.Id];\n        }\n        return [];\n    });\n}\n/**\n * Given a relationship definition within a source model (`sourceModelName`, `sourceConnectionField`) and\n * the associated model (`associatedModel`), this finds the connection field for the relationship defined on the\n * associated model. Invalid states, such a 0 or >1 matching connection fields result in an error.\n * @param sourceModelName\n * @param sourceConnectionField\n * @param associatedModel\n * @returns\n */\nfunction getAssociatedConnectionField(sourceModelName, sourceConnectionField, associatedModel) {\n    const associatedRelationshipOptions = associatedRelationshipTypes(sourceConnectionField.def.type);\n    // Iterate through the associated model's fields to find the associated connection field for the relationship defined on the source model.\n    const associatedConnectionFieldCandidates = Object.entries(associatedModel.data.fields).filter(([_key, connectionField]) => {\n        // If the field isn't a model, it's not part of the relationship definition -- ignore the field.\n        if (!isModelField(connectionField)) {\n            return false;\n        }\n        // In order to find that associated connection field, we need to do some validation that we'll depend on further downstream.\n        // 1. Field type matches the source model's type.\n        // 2. A valid counterpart relationship modifier is defined on the field. See `associatedRelationshipTypes` for more information.\n        // 3. The reference arguments provided to the field match (element count + string comparison) references passed to the source connection field.\n        return (connectionField.data.relatedModel === sourceModelName &&\n            associatedRelationshipOptions.includes(connectionField.data.type) &&\n            connectionField.data.references.length ===\n                sourceConnectionField.def.references.length &&\n            connectionField.data.references.every((value, index) => value === sourceConnectionField.def.references[index]));\n    });\n    // We should have found exactly one connection field candidate. If that's not the case, we need to throw a validation error.\n    if (associatedConnectionFieldCandidates.length != 1) {\n        // const associatedModelDescription = sourceConnectionField.def.array\n        // ? `[${sourceConnectionField.def.relatedModel}]`\n        // : sourceConnectionField.def.relatedModel\n        const sourceConnectionFieldDescription = describeConnectFieldRelationship(sourceConnectionField, sourceModelName); // `${sourceModelName}.${sourceConnectionField.name}: ${associatedModelDescription} @${sourceConnectionField.def.type}(references: [${sourceConnectionField.def.references}])`\n        const errorMessage = associatedConnectionFieldCandidates.length === 0\n            ? `Unable to find associated relationship definition in ${sourceConnectionField.def.relatedModel}`\n            : `Found multiple relationship associations with ${associatedConnectionFieldCandidates.map((field) => `${sourceConnectionField.def.relatedModel}.${field[0]}`).join(', ')}`;\n        throw new Error(`${errorMessage} for ${sourceConnectionFieldDescription}`);\n    }\n    const associatedConnectionField = associatedConnectionFieldCandidates[0];\n    if (!isModelField(associatedConnectionField[1])) {\n        // This shouldn't happen because we've validated that it's a model field above.\n        // However it's necessary to narrow the type.\n        // const associatedModelDescription = sourceConnectionField.def.array\n        // ? `[${sourceConnectionField.def.relatedModel}]`\n        // : sourceConnectionField.def.relatedModel\n        const sourceConnectionFieldDescription = describeConnectFieldRelationship(sourceConnectionField, sourceModelName);\n        const errorMessage = `Cannot find counterpart to relationship defintion for ${sourceConnectionFieldDescription}`;\n        throw new Error(errorMessage);\n    }\n    return {\n        name: associatedConnectionField[0],\n        def: associatedConnectionField[1].data,\n    };\n}\n/**\n * Given either side of a relationship (source), this retrieves the other side (related)\n * and packages the information neatly into a {@link ModelRelationship} for validation purposes.\n *\n * @param sourceModelName\n * @param sourceConnectionField\n * @param getInternalModel\n * @returns a {@link ModelRelationship}\n */\nfunction getModelRelationship(sourceModelName, sourceModelConnectionField, getInternalModel) {\n    const sourceModel = getInternalModel(sourceModelName, sourceModelName);\n    const associatedModel = getInternalModel(sourceModelConnectionField.def.relatedModel, sourceModelName);\n    const relatedModelConnectionField = getAssociatedConnectionField(sourceModelName, sourceModelConnectionField, associatedModel);\n    switch (sourceModelConnectionField.def.type) {\n        case ModelRelationshipField_1.ModelRelationshipTypes.hasOne:\n        case ModelRelationshipField_1.ModelRelationshipTypes.hasMany:\n            return {\n                parent: sourceModel,\n                parentConnectionField: sourceModelConnectionField,\n                child: associatedModel,\n                childConnectionField: relatedModelConnectionField,\n                references: sourceModelConnectionField.def.references,\n            };\n        case ModelRelationshipField_1.ModelRelationshipTypes.belongsTo:\n            return {\n                parent: associatedModel,\n                parentConnectionField: relatedModelConnectionField,\n                child: sourceModel,\n                childConnectionField: sourceModelConnectionField,\n                references: sourceModelConnectionField.def.references,\n            };\n        default:\n            throw new Error(`\"${sourceModelConnectionField.def.type}\" is not a valid relationship type.`);\n    }\n}\n/**\n *\n * @param disabledOps\n * @returns sanitized string @model directive attribute; can be passed in as-is\n *\n * @example\n * ```ts\n * const disabledOps = [\"subscriptions\", \"create\"];\n * ```\n * returns\n * ```\n * subscriptions:null,mutations:{create:null}\n * ```\n */\nfunction modelAttributesFromDisabledOps(disabledOps) {\n    const fineCoarseMap = {\n        onCreate: 'subscriptions',\n        onUpdate: 'subscriptions',\n        onDelete: 'subscriptions',\n        create: 'mutations',\n        update: 'mutations',\n        delete: 'mutations',\n        list: 'queries',\n        get: 'queries',\n    };\n    const coarseGrainedOps = ['queries', 'mutations', 'subscriptions'];\n    const coarseFirstSorted = disabledOps\n        // disabledOps is readOnly; create a copy w/ slice\n        .slice()\n        .sort((a, b) => {\n        if (coarseGrainedOps.includes(a) && !coarseGrainedOps.includes(b)) {\n            return -1;\n        }\n        if (!coarseGrainedOps.includes(a) && coarseGrainedOps.includes(b)) {\n            return 1;\n        }\n        return 0;\n    });\n    const modelAttrs = {};\n    for (const op of coarseFirstSorted) {\n        if (coarseGrainedOps.includes(op)) {\n            modelAttrs[op] = null;\n            continue;\n        }\n        const coarseOp = fineCoarseMap[op];\n        if (modelAttrs[coarseOp] !== null) {\n            modelAttrs[coarseOp] = modelAttrs[coarseOp] || {};\n            modelAttrs[coarseOp][op] = null;\n        }\n    }\n    const modelAttrsStr = JSON.stringify(modelAttrs)\n        .replace(/\"/g, '') // remove quotes\n        .slice(1, -1); // drop outer curlies {}\n    return modelAttrsStr;\n}\n/**\n * Returns API definition from ModelSchema or string schema\n * @param arg - { schema }\n * @returns DerivedApiDefinition that conforms to IAmplifyGraphqlDefinition\n */\nfunction processSchema(arg) {\n    const { schema, jsFunctions, functionSchemaAccess, lambdaFunctions, customSqlDataSourceStrategies, } = schemaPreprocessor(arg.schema);\n    return {\n        schema,\n        functionSlots: [],\n        jsFunctions,\n        functionSchemaAccess,\n        lambdaFunctions,\n        customSqlDataSourceStrategies,\n    };\n}\nexports.processSchema = processSchema;\n"],"names":[],"mappings":"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"}