{"version":3,"file":"getPaddedHex.js","sources":["../../../../../../src/providers/cognito/utils/srp/getPaddedHex.ts"],"sourcesContent":["\"use strict\";\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getPaddedHex = void 0;\nconst BigInteger_1 = require(\"./BigInteger\");\n/**\n * Tests if a hex string has it most significant bit set (case-insensitive regex)\n */\nconst HEX_MSB_REGEX = /^[89a-f]/i;\n/**\n * Returns an unambiguous, even-length hex string of the two's complement encoding of an integer.\n *\n * It is compatible with the hex encoding of Java's BigInteger's toByteArray(), wich returns a\n * byte array containing the two's-complement representation of a BigInteger. The array contains\n * the minimum number of bytes required to represent the BigInteger, including at least one sign bit.\n *\n * Examples showing how ambiguity is avoided by left padding with:\n * \t\"00\" (for positive values where the most-significant-bit is set)\n *  \"FF\" (for negative values where the most-significant-bit is set)\n *\n * padHex(bigInteger.fromInt(-236))  === \"FF14\"\n * padHex(bigInteger.fromInt(20))    === \"14\"\n *\n * padHex(bigInteger.fromInt(-200))  === \"FF38\"\n * padHex(bigInteger.fromInt(56))    === \"38\"\n *\n * padHex(bigInteger.fromInt(-20))   === \"EC\"\n * padHex(bigInteger.fromInt(236))   === \"00EC\"\n *\n * padHex(bigInteger.fromInt(-56))   === \"C8\"\n * padHex(bigInteger.fromInt(200))   === \"00C8\"\n *\n * @param {AuthBigInteger} bigInt Number to encode.\n * @returns {String} even-length hex string of the two's complement encoding.\n */\nconst getPaddedHex = (bigInt) => {\n    if (!(bigInt instanceof BigInteger_1.BigInteger)) {\n        throw new Error('Not a BigInteger');\n    }\n    const isNegative = bigInt.compareTo(BigInteger_1.BigInteger.ZERO) < 0;\n    /* Get a hex string for abs(bigInt) */\n    let hexStr = bigInt.abs().toString(16);\n    /* Pad hex to even length if needed */\n    hexStr = hexStr.length % 2 !== 0 ? `0${hexStr}` : hexStr;\n    /* Prepend \"00\" if the most significant bit is set */\n    hexStr = HEX_MSB_REGEX.test(hexStr) ? `00${hexStr}` : hexStr;\n    if (isNegative) {\n        /* Flip the bits of the representation */\n        const invertedNibbles = hexStr\n            .split('')\n            .map((x) => {\n            const invertedNibble = ~parseInt(x, 16) & 0xf;\n            return '0123456789ABCDEF'.charAt(invertedNibble);\n        })\n            .join('');\n        /* After flipping the bits, add one to get the 2's complement representation */\n        const flippedBitsBI = new BigInteger_1.BigInteger(invertedNibbles, 16).add(BigInteger_1.BigInteger.ONE);\n        hexStr = flippedBitsBI.toString(16);\n        /*\n        For hex strings starting with 'FF8', 'FF' can be dropped, e.g. 0xFFFF80=0xFF80=0x80=-128\n\n        Any sequence of '1' bits on the left can always be substituted with a single '1' bit\n        without changing the represented value.\n\n        This only happens in the case when the input is 80...00\n        */\n        if (hexStr.toUpperCase().startsWith('FF8')) {\n            hexStr = hexStr.substring(2);\n        }\n    }\n    return hexStr;\n};\nexports.getPaddedHex = getPaddedHex;\n"],"names":[],"mappings":";;AACA;AACA;AACA,MAAM,CAAC,cAAc,CAAC,OAAO,EAAE,YAAY,EAAE,EAAE,KAAK,EAAE,IAAI,EAAE,CAAC,CAAC;AAC9D,OAAO,CAAC,YAAY,GAAG,KAAK,CAAC,CAAC;AAC9B,MAAM,YAAY,GAAG,OAAO,CAAC,cAAc,CAAC,CAAC;AAC7C;AACA;AACA;AACA,MAAM,aAAa,GAAG,WAAW,CAAC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,YAAY,GAAG,CAAC,MAAM,KAAK;AACjC,IAAI,IAAI,EAAE,MAAM,YAAY,YAAY,CAAC,UAAU,CAAC,EAAE;AACtD,QAAQ,MAAM,IAAI,KAAK,CAAC,kBAAkB,CAAC,CAAC;AAC5C,KAAK;AACL,IAAI,MAAM,UAAU,GAAG,MAAM,CAAC,SAAS,CAAC,YAAY,CAAC,UAAU,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;AAC1E;AACA,IAAI,IAAI,MAAM,GAAG,MAAM,CAAC,GAAG,EAAE,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC;AAC3C;AACA,IAAI,MAAM,GAAG,MAAM,CAAC,MAAM,GAAG,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,EAAE,MAAM,CAAC,CAAC,GAAG,MAAM,CAAC;AAC7D;AACA,IAAI,MAAM,GAAG,aAAa,CAAC,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,EAAE,EAAE,MAAM,CAAC,CAAC,GAAG,MAAM,CAAC;AACjE,IAAI,IAAI,UAAU,EAAE;AACpB;AACA,QAAQ,MAAM,eAAe,GAAG,MAAM;AACtC,aAAa,KAAK,CAAC,EAAE,CAAC;AACtB,aAAa,GAAG,CAAC,CAAC,CAAC,KAAK;AACxB,YAAY,MAAM,cAAc,GAAG,CAAC,QAAQ,CAAC,CAAC,EAAE,EAAE,CAAC,GAAG,GAAG,CAAC;AAC1D,YAAY,OAAO,kBAAkB,CAAC,MAAM,CAAC,cAAc,CAAC,CAAC;AAC7D,SAAS,CAAC;AACV,aAAa,IAAI,CAAC,EAAE,CAAC,CAAC;AACtB;AACA,QAAQ,MAAM,aAAa,GAAG,IAAI,YAAY,CAAC,UAAU,CAAC,eAAe,EAAE,EAAE,CAAC,CAAC,GAAG,CAAC,YAAY,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC;AAChH,QAAQ,MAAM,GAAG,aAAa,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,IAAI,MAAM,CAAC,WAAW,EAAE,CAAC,UAAU,CAAC,KAAK,CAAC,EAAE;AACpD,YAAY,MAAM,GAAG,MAAM,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;AACzC,SAAS;AACT,KAAK;AACL,IAAI,OAAO,MAAM,CAAC;AAClB,CAAC,CAAC;AACF,OAAO,CAAC,YAAY,GAAG,YAAY;;"}